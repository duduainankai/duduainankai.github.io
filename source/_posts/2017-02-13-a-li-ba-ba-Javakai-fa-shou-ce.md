---
layout: post
title: "阿里巴巴Java开发手册"
date: 2017-02-13 20:03:05 +0800
comments: true
categories: Java
---

&emsp;&emsp;年不知不觉就过完了，马上又要开学了，不是很开心。快乐的时间总是特别短暂，前天晚上还在家里的街上开着车和同学鬼哭狼嚎其实不想走其实我想留(是真的不想走)，然后今天就已经到学校了。

&emsp;&emsp;一个假期干的事情也不多，在家陪陪妈妈打打麻将和同学每天吃吃喝喝就已经去掉一大半时间了，正事干的也不多。前两天刷知乎的时候看到大家在讨论阿里出的一个Java开发手册，评论还不错于是找来看了看，收获不小也有很多切身体会，写篇博客小小的记录一下吧。<!--more-->

> 【强制】 代码中的命名严禁使用拼音与英文混合的方式,更不允许直接使用中文的方式。 说明:正确的英文拼写和语法可以让阅读者易于理解,避免歧义。注意,即使纯拼音命名方式 也要避免采用。 <br/>
>【强制】类名使用 UpperCamelCase 风格,必须遵从驼峰形式,但以下情形例外:(领域模型 的相关命名)DO / BO / DTO / VO等。<br/>
>【强制】方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格,必须遵从 驼峰形式。<br/>
>【强制】常量命名全部大写,单词间用下划线隔开,力求语义表达完整清楚,不要嫌名字长。

&emsp;&emsp;用拼音命名感觉会很别扭，但是我在做OJ的时候也确实这么干过。。还好做项目的时候没有试过，相似的是在上个学期碰见过用中文做数据库表名的，让我看的一阵蛋疼。至于驼峰命名法也是感觉还是挺常见的习惯，也一直在用，顺便提供一个[变量命名神器](http://unbug.github.io/codelf/#%E9%A2%84%E5%AE%9A)。

> 【强制】POJO 类中布尔类型的变量,都不要加 is,否则部分框架解析会引起序列化错误。 反例:定义为基本数据类型boolean isSuccess;的属性,它的方法也是isSuccess(),RPC 框架在反向解析的时候,“以为”对应的属性名称是 success,导致属性获取不到,进而抛出异常。

&emsp;&emsp;好像是阿里内部有踩过这样的坑，虽然还没有碰到过但还是记下来比较好。

> 【推荐】接口类中的方法和属性不要加任何修饰符号(public 也不要加),保持代码的简洁性,并加上有效的Javadoc注释。尽量不要在接口里定义变量,如果一定要定义变量,肯定是与接口方法相关,并且是整个应用的基础常量。

&emsp;&emsp;这条还是第一次看见，知乎上R大的解释是：Java的interface声明的成员方法，默认就是public abstract的，所以这两个修饰符别出来就是最简洁明了的写法；而interface里声明的变量默认就是public static final的——只能声明共有常量，所以这些修饰符也是不要写出来最简单明了。

> 【强制】if/for/while/switch/do 等保留字与左右括号之间都必须加空格。<br/>
> 【强制】任何运算符左右必须加一个空格。<br/>
> 【强制】缩进采用4个空格,禁止使用tab字符。

&emsp;&emsp;前两条也是用了很久都产生强迫症了，看别人的代码不加都会难受。有种说法叫真的程序员都是四个空格从不用tab，但是我经常偷懒按tab，在python上翻过好几次车。

>【强制】关于基本数据类型与包装数据类型的使用标准如下:<br/>1) 所有的 POJO 类属性必须使用包装数据类型。<br/>2) RPC方法的返回值和参数必须使用包装数据类型。<br/>3) 所有的局部变量【推荐】使用基本数据类型。

&emsp;&emsp;NPE应该是Java中最常见的异常了，特别是在Java提供了自动拆箱的功能以后，这样的bug有时候很难发现，也是原先没有注意到的一点。

>【推荐】使用索引访问用 String 的 split 方法得到的数组时,需做最后一个分隔符后有无内容的检查,否则会有抛 IndexOutOfBoundsException 的风险。说明:<br/>String str = "a,b,c,,";<br/>String[] ary = str.split(","); //预期大于 3,结果是 3 <br/>System.out.println(ary.length);<br/>

&emsp;&emsp;这一条也是很有意思，split函数看上去很方便但其实坑不少。首先它接收的参数是一个string，但会首先判断这个string是不是一个正则表达式，也就是说如果这个string包含了.?等等的字符的话并不能按照预期的通过.来分割原来的字符串，而要将这个.进行转义，也就是参数应该是\\.。其次对于分割完成的结果，函数会从后往前遍历，如果得到的是个空串，那么这个空串会被舍弃掉直到遇到第一个不是空串的位置停止，最后返回的结果是从起始位置到倒数第一个非空串为止，也就是上面的例子最后输出的数组长度是3而不是4的原因了。

>【强制】不要在foreach循环里进行元素的remove/add操作。remove元素请使用Iterator方式,如果并发操作,需要对Iterator对象加锁。

&emsp;&emsp;这是Java的fast fail机制：当多个线程对同一个集合的内容进行操作的时候，某一个线程通过iterator去遍历集合的过程中发现集合的内容被其他线程修改了，就会抛出ConcurrentModificationException异常，产生fast fail事件。这是因为在迭代器在调用next()和remove()方法时都会执行checkForComodification()方法，如果modCount不等于expectedModCount就会抛出异常，而只有当迭代器迭代过程中集合进行了会影响个数的操作之后才有可能发生这种情况。而为了达到多个线程对同一个集合进行修改的目的，应该采用concurrent包下的并发集合类，比如CopyOnWriteArrayList，此时所有的修改会通过在原来的数组的拷贝上进行来避免冲突。

> 【强制】线程资源必须通过线程池􏰁供,不允许在应用中自行显式创建线程。<br/>
> 【强制】线程池不允许使用 Executors 去创建,而是通过 ThreadPoolExecutor 的方式,这样 的处理方式让写的同学更加明确线程池的运行规则,规避资源耗尽的风险。<br/>
> 说明:Executors 返回的线程池对象的弊端如下:<br/>1) FixedThreadPool 和 SingleThreadPool:<br/>允许的请求队列长度为 Integer.MAX_VALUE,可能会堆积大量的请求,从而导致 OOM。<br/>2) CachedThreadPool 和 ScheduledThreadPool:<br/>允许的创建线程数量为 Integer.MAX_VALUE,可能会创建大量的线程,从而导致 OOM。<br/>

&emsp;&emsp;对于第一点还是很容易理解的，因为频繁的创建销毁线程会带来额外的系统资源的开销。第二点也是原先没有太注意的地方，学习了。

####总结

&emsp;&emsp;看完收获还是很多的，也小小弥补了一下假期太放松带来的罪恶感。不过这个上面刚说到运算符前后要留空格到下面其他总结中自己举得代码例子就没遵守是什么鬼。

&emsp;&emsp;想来很多都是阿里人自己踩过坑得到的经验，很多我还没有经历过的可能感觉不那么重要，比如会用FixedThreadPool会有OOM的可能这件事，做个小项目的话很哪有这种经历的吧。不过写代码大概就是这样一件有趣的事，自己踩过的坑吃过的苦才会记忆的更加深刻吧。

&emsp;&emsp;马上也快找工作了，希望也能有机会加入阿里这样的大公司踩一踩坑吧。加油。